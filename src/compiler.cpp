//--------------------------------------------
// COW PROGRAMMING LANGUAGE - Modern Compiler
//--------------------------------------------
#include "cow/parser.hpp"
#include "cow/instruction.hpp"

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <stack>

// Detect compiler from environment or use default
std::string detectCompiler() {
    const char* env_compiler = std::getenv("CXX");
    if (env_compiler) {
        return env_compiler;
    }

    // Try to detect available compiler
    if (std::system("which g++ > /dev/null 2>&1") == 0) {
        return "g++";
    }
    if (std::system("which clang++ > /dev/null 2>&1") == 0) {
        return "clang++";
    }
    if (std::system("which c++ > /dev/null 2>&1") == 0) {
        return "c++";
    }

    return "g++";  // Default fallback
}

void printUsage(const char* program_name) {
    std::cout << "COW Programming Language Compiler (Modern C++ Version)\n"
              << "Original by BigZaphod (Sean Heber) - Modernized version\n\n"
              << "Usage: " << program_name << " [options] <program.cow>\n\n"
              << "Options:\n"
              << "  -h, --help         Show this help message\n"
              << "  -o <file>          Output executable name (default: cow.out)\n"
              << "  --cxx <compiler>   C++ compiler to use (default: auto-detect)\n"
              << "  --cpp-only         Only generate C++ source, don't compile\n"
              << "  -O0, -O1, -O2, -O3 Optimization level (default: -O3)\n"
              << "  -k, --keep         Keep generated C++ source file\n"
              << "\nEnvironment variables:\n"
              << "  CXX                C++ compiler to use\n"
              << "  CXXFLAGS           Additional compiler flags\n\n";
}

// Pre-compute loop matching - returns pairs of (MOO_pos -> moo_pos) and (moo_pos -> MOO_pos)
void computeLoopMatching(const std::vector<cow::Instruction>& program,
                         std::vector<int>& moo_target_for_MOO,  // For each MOO at pos i, jump to which moo
                         std::vector<int>& MOO_target_for_moo) { // For each moo at pos i, jump to which MOO
    moo_target_for_MOO.resize(program.size(), -1);
    MOO_target_for_moo.resize(program.size(), -1);

    std::stack<size_t> loop_stack;

    for (size_t i = 0; i < program.size(); ++i) {
        if (program[i].op == cow::OpCode::MOO_Upper) {
            loop_stack.push(i);
        } else if (program[i].op == cow::OpCode::Moo_Lower) {
            if (!loop_stack.empty()) {
                size_t MOO_pos = loop_stack.top();
                loop_stack.pop();
                moo_target_for_MOO[MOO_pos] = static_cast<int>(i);
                MOO_target_for_moo[i] = static_cast<int>(MOO_pos);
            }
        }
    }
}

std::string generateCppCode(const std::vector<cow::Instruction>& program) {
    std::stringstream out;

    // Pre-compute loop matching
    std::vector<int> moo_target_for_MOO;
    std::vector<int> MOO_target_for_moo;
    computeLoopMatching(program, moo_target_for_MOO, MOO_target_for_moo);

    // Assign labels to loop instructions
    // Each MOO/moo pair gets a unique label number
    std::vector<int> MOO_label(program.size(), -1);
    std::vector<int> moo_label(program.size(), -1);
    int label_counter = 0;

    for (size_t i = 0; i < program.size(); ++i) {
        if (program[i].op == cow::OpCode::MOO_Upper) {
            MOO_label[i] = ++label_counter;
        }
    }

    // Assign moo labels based on matching MOO
    for (size_t i = 0; i < program.size(); ++i) {
        if (program[i].op == cow::OpCode::Moo_Lower) {
            int matching_MOO = MOO_target_for_moo[i];
            if (matching_MOO >= 0) {
                moo_label[i] = MOO_label[matching_MOO];  // Same label as matching MOO
            }
        }
    }

    // Header
    out << "// Generated by COW Compiler v2.0\n"
        << "#include <cstdio>\n"
        << "#include <vector>\n"
        << "#include <iostream>\n\n"
        << "int main(int argc, char** argv) {\n"
        << "    // Memory and state\n"
        << "    std::vector<int> memory(30000, 0);\n"
        << "    size_t memory_ptr = 0;\n"
        << "    int register_val = 0;\n"
        << "    bool has_register_val = false;\n"
        << "    bool running = true;\n\n";

    // Generate code for each instruction
    for (size_t i = 0; i < program.size(); ++i) {
        const auto& inst = program[i];

        switch (inst.op) {
            case cow::OpCode::Moo_Lower: {
                // moo - loop end: jump back if memory != 0
                int my_label = moo_label[i];
                int target_MOO = MOO_target_for_moo[i];
                int target_label = (target_MOO >= 0) ? MOO_label[target_MOO] : 0;

                out << "    // moo\n";
                if (target_label > 0) {
                    out << "    if (running && memory[memory_ptr] != 0) goto MOO_" << target_label << ";\n";
                }
                out << "    moo_" << my_label << ": ;\n";
                break;
            }

            case cow::OpCode::mOo:
                out << "    // mOo\n";
                out << "    if (memory_ptr == 0) { std::cerr << \"Runtime error: memory underflow\\n\"; }\n";
                out << "    else { memory_ptr--; }\n";
                break;

            case cow::OpCode::moO:
                out << "    // moO\n";
                out << "    memory_ptr++;\n";
                out << "    if (memory_ptr >= memory.size()) memory.push_back(0);\n";
                break;

            case cow::OpCode::mOO:
                out << "    // mOO - dynamic dispatch\n";
                out << "    switch (memory[memory_ptr]) {\n";
                out << "        case 3: running = false; break;\n";
                for (int j = 0; j < 12; ++j) {
                    if (j == 3) continue;  // Skip 3 (exit)
                    out << "        case " << j << ": {\n";
                    // Inline simple instructions for common cases
                    switch (static_cast<cow::OpCode>(j)) {
                        case cow::OpCode::mOo:
                            out << "            if (memory_ptr == 0) { std::cerr << \"Memory underflow\\n\"; }\n";
                            out << "            else { memory_ptr--; }\n";
                            break;
                        case cow::OpCode::moO:
                            out << "            memory_ptr++;\n";
                            out << "            if (memory_ptr >= memory.size()) memory.push_back(0);\n";
                            break;
                        case cow::OpCode::MOo:
                            out << "            memory[memory_ptr]--;\n";
                            break;
                        case cow::OpCode::MoO:
                            out << "            memory[memory_ptr]++;\n";
                            break;
                        case cow::OpCode::OOO:
                            out << "            memory[memory_ptr] = 0;\n";
                            break;
                        case cow::OpCode::OOM:
                            out << "            std::printf(\"%d\\n\", memory[memory_ptr]);\n";
                            break;
                        default:
                            out << "            /* instruction " << j << " not implemented in mOO */\n";
                            break;
                    }
                    out << "        } break;\n";
                }
                out << "        default: break;\n";
                out << "    }\n";
                break;

            case cow::OpCode::Moo_Mixed:
                out << "    // Moo\n";
                out << "    if (memory[memory_ptr] != 0) {\n";
                out << "        std::putchar(memory[memory_ptr]);\n";
                out << "    } else {\n";
                out << "        memory[memory_ptr] = std::getchar();\n";
                out << "        int c; while ((c = std::getchar()) != '\\n' && c != EOF);\n";
                out << "    }\n";
                break;

            case cow::OpCode::MOo:
                out << "    // MOo\n";
                out << "    memory[memory_ptr]--;\n";
                break;

            case cow::OpCode::MoO:
                if (inst.argument > 1) {
                    out << "    // MoO (optimized: +" << inst.argument << ")\n";
                    out << "    memory[memory_ptr] += " << inst.argument << ";\n";
                } else {
                    out << "    // MoO\n";
                    out << "    memory[memory_ptr]++;\n";
                }
                break;

            case cow::OpCode::MOO_Upper: {
                // MOO - loop start: skip to matching moo if memory == 0
                int my_label = MOO_label[i];
                int target_moo = moo_target_for_MOO[i];
                int target_label = (target_moo >= 0) ? moo_label[target_moo] : 0;

                out << "    // MOO\n";
                out << "    MOO_" << my_label << ": ;\n";
                if (target_label > 0) {
                    out << "    if (!running || memory[memory_ptr] == 0) goto moo_" << target_label << ";\n";
                }
                break;
            }

            case cow::OpCode::OOO:
                out << "    // OOO\n";
                out << "    memory[memory_ptr] = 0;\n";
                break;

            case cow::OpCode::MMM:
                out << "    // MMM\n";
                out << "    if (has_register_val) { memory[memory_ptr] = register_val; }\n";
                out << "    else { register_val = memory[memory_ptr]; }\n";
                out << "    has_register_val = !has_register_val;\n";
                break;

            case cow::OpCode::OOM:
                out << "    // OOM\n";
                out << "    std::printf(\"%d\\n\", memory[memory_ptr]);\n";
                break;

            case cow::OpCode::oom:
                out << "    // oom\n";
                out << "    { char buf[100]; std::fgets(buf, sizeof(buf), stdin);\n";
                out << "      memory[memory_ptr] = std::atoi(buf); }\n";
                break;

            default:
                break;
        }
    }

    out << "\n    return 0;\n}\n";
    return out.str();
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printUsage(argv[0]);
        return 1;
    }

    std::string filename;
    std::string output_name = "cow.out";
    std::string compiler = detectCompiler();
    std::string optimization = "-O3";
    bool cpp_only = false;
    bool keep_cpp = false;

    // Parse arguments
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];

        if (arg == "-h" || arg == "--help") {
            printUsage(argv[0]);
            return 0;
        } else if (arg == "-o" && i + 1 < argc) {
            output_name = argv[++i];
        } else if (arg == "--cxx" && i + 1 < argc) {
            compiler = argv[++i];
        } else if (arg == "--cpp-only") {
            cpp_only = true;
        } else if (arg == "-k" || arg == "--keep") {
            keep_cpp = true;
        } else if (arg == "-O0") {
            optimization = "-O0";
        } else if (arg == "-O1") {
            optimization = "-O1";
        } else if (arg == "-O2") {
            optimization = "-O2";
        } else if (arg == "-O3") {
            optimization = "-O3";
        } else if (arg[0] != '-') {
            filename = arg;
        } else {
            std::cerr << "Unknown option: " << arg << "\n";
            return 1;
        }
    }

    if (filename.empty()) {
        std::cerr << "Error: No input file specified\n";
        printUsage(argv[0]);
        return 1;
    }

    try {
        // Parse the program
        std::cout << "Compiling: " << filename << "...\n";
        auto program = cow::Parser::parseFile(filename);
        std::cout << "Parsed " << program.size() << " instructions\n";

        // Generate C++ code
        std::string cpp_code = generateCppCode(program);
        std::string cpp_filename = output_name + ".cpp";

        // Write C++ source
        std::ofstream cpp_file(cpp_filename);
        if (!cpp_file.is_open()) {
            std::cerr << "Error: Cannot write to " << cpp_filename << "\n";
            return 1;
        }
        cpp_file << cpp_code;
        cpp_file.close();

        std::cout << "Generated C++ source: " << cpp_filename << "\n";

        if (cpp_only) {
            return 0;
        }

        // Compile to executable
        std::stringstream cmd;
        cmd << compiler << " " << optimization << " -std=c++17 ";

        // Add environment flags
        const char* cxxflags = std::getenv("CXXFLAGS");
        if (cxxflags) {
            cmd << cxxflags << " ";
        }

        cmd << "-o " << output_name << " " << cpp_filename;

        std::cout << "Invoking: " << cmd.str() << "\n";
        int result = std::system(cmd.str().c_str());

        if (result != 0) {
            std::cerr << "\nCompilation failed. Possible causes:\n";
            std::cerr << "  - C++ compiler '" << compiler << "' not found\n";
            std::cerr << "  - Compiler not in PATH\n";
            std::cerr << "  - Syntax errors in generated code\n";
            std::cerr << "\nYou can specify a different compiler with:\n";
            std::cerr << "  --cxx <compiler> or set CXX environment variable\n";
            return 1;
        }

        std::cout << "Executable created: " << output_name << "\n";

        // Clean up unless --keep was specified
        if (!keep_cpp) {
            std::remove(cpp_filename.c_str());
        } else {
            std::cout << "Kept C++ source: " << cpp_filename << "\n";
        }

        return 0;

    } catch (const cow::ParseException& e) {
        std::cerr << "Parse error: " << e.what() << "\n";
        return 1;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }
}
